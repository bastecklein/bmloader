<!DOCTYPE html>
<html>
<head>
    <title>BMLoader Group Transform Test</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 400px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border-radius: 3px;
        }
        button:hover { background: #45a049; }
    </style>
</head>
<body>
    <div id="info">
        <h3>BMLoader Group Transform Test</h3>
        <p>Testing if group transforms are properly applied during geometry merging.</p>
        <button onclick="loadAndTest()">Load & Test Model</button>
        <button onclick="mergeModel()">Merge Geometry</button>
        <div id="results"></div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.164.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.164.0/examples/jsm/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let bmModel = null;

        // Initialize Three.js scene
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Create test BM data based on the user's example
        const testBMData = {
            script: `
                $caseInner = #333333;
                $caseColor = #666666;
                $bulletCasingColor = #c5aa3d;
                $bulletHeadColor = #7a4928;

                box(1.25, 3.0, 0.75, $caseInner) > position(0, 1.5, 0);

                box(0.3, 3.1, 0.8, $caseColor) > position(0.5, 1.55, 0);
                box(0.3, 2.9, 0.8, $caseColor) > position(-0.5, 1.5, 0);
                box(1.25, 0.5, 0.8, $caseColor) > position(0, 0.25, 0);
                box(1.3, 0.5, 0.2, $caseColor) > position(0, 2.85, 0.3);
                box(1.3, 0.5, 0.2, $caseColor) > position(0, 2.85, -0.3);

                $bullet = startgroup();

                cylinder(0.5, 0.5, 2, 8, $bulletCasingColor) > position(0, 0, 0);
                capsule(0.45, 1, 4, 8, $bulletHeadColor) > position(0, 1, 0);

                endgroup();

                $bullet > position(0.18, 3, 0) > scale(0.38, 0.38, 0.38) > rotate(90, 0, 90);
            `,
            textures: {},
            animations: {}
        };

        // Mock BMLoader class - simplified version for testing
        class MockBMLoader {
            constructor() {
                this.path = '';
            }

            // Simplified load method that processes our test data
            async load(data, onLoad) {
                const model = await this.processTestData(data);
                onLoad(model);
                return model;
            }

            async processTestData(data) {
                // This would normally be much more complex
                // For now, just create a simple test case
                const group = new THREE.Group();
                
                // Create bullet group
                const bulletGroup = new THREE.Group();
                
                // Add bullet components
                const cylinderGeo = new THREE.CylinderGeometry(0.25, 0.25, 2, 8);
                const cylinderMat = new THREE.MeshStandardMaterial({ color: 0xc5aa3d });
                const cylinder = new THREE.Mesh(cylinderGeo, cylinderMat);
                cylinder.position.set(0, 0, 0);
                bulletGroup.add(cylinder);

                const capsuleGeo = new THREE.CapsuleGeometry(0.45, 1, 4, 8);
                const capsuleMat = new THREE.MeshStandardMaterial({ color: 0x7a4928 });
                const capsule = new THREE.Mesh(capsuleGeo, capsuleMat);
                capsule.position.set(0, 1, 0);
                bulletGroup.add(capsule);

                // Apply group transforms
                bulletGroup.position.set(0.18, 3, 0);
                bulletGroup.scale.set(0.38, 0.38, 0.38);
                bulletGroup.rotation.set(
                    THREE.MathUtils.degToRad(90),
                    THREE.MathUtils.degToRad(0),
                    THREE.MathUtils.degToRad(90)
                );

                group.add(bulletGroup);

                // Add case boxes
                const caseGeo1 = new THREE.BoxGeometry(1.25, 3.0, 0.75);
                const caseMat1 = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const case1 = new THREE.Mesh(caseGeo1, caseMat1);
                case1.position.set(0, 1.5, 0);
                group.add(case1);

                // Mock the bmDat structure
                group.bmDat = {
                    variables: {
                        bullet: bulletGroup
                    }
                };

                // Mock the createMergedMesh method
                group.createMergedMesh = function(options = {}) {
                    console.log('Testing merge with group transforms...');
                    
                    // Collect all meshes
                    const meshes = [];
                    this.traverse((child) => {
                        if (child.isMesh) {
                            meshes.push(child);
                        }
                    });

                    console.log(`Found ${meshes.length} meshes to test`);
                    
                    // Test transform matrix calculation
                    meshes.forEach((mesh, index) => {
                        console.log(`\nMesh ${index}:`);
                        console.log('  Mesh world position:', mesh.getWorldPosition(new THREE.Vector3()));
                        console.log('  Mesh local position:', mesh.position);
                        
                        // Test parent hierarchy
                        let parent = mesh.parent;
                        let level = 1;
                        while (parent && parent !== this) {
                            console.log(`  Parent ${level} position:`, parent.position);
                            console.log(`  Parent ${level} scale:`, parent.scale);
                            console.log(`  Parent ${level} rotation:`, parent.rotation);
                            parent = parent.parent;
                            level++;
                        }
                    });

                    return {
                        canMerge: true,
                        analysis: {
                            originalDrawCalls: meshes.length,
                            mergedDrawCalls: 1,
                            savings: meshes.length - 1
                        }
                    };
                };

                return group;
            }
        }

        window.loadAndTest = async function() {
            const loader = new MockBMLoader();
            bmModel = await loader.load(testBMData, (model) => {
                scene.add(model);
                
                const results = document.getElementById('results');
                results.innerHTML = `
                    <h4>Model Loaded</h4>
                    <p>Meshes: ${Array.from(model.children).filter(c => c.isMesh || (c.children && c.children.some(cc => cc.isMesh))).length}</p>
                    <p>Check console for transform details</p>
                `;

                // Update world matrices and log positions
                model.updateMatrixWorld(true);
                
                console.log('Model structure:');
                model.traverse((child) => {
                    if (child.isMesh) {
                        const worldPos = child.getWorldPosition(new THREE.Vector3());
                        console.log(`Mesh: local=${child.position.x.toFixed(2)},${child.position.y.toFixed(2)},${child.position.z.toFixed(2)} world=${worldPos.x.toFixed(2)},${worldPos.y.toFixed(2)},${worldPos.z.toFixed(2)}`);
                    }
                });
            });
        };

        window.mergeModel = function() {
            if (!bmModel) {
                alert('Load model first!');
                return;
            }

            const result = bmModel.createMergedMesh({ dryRun: true });
            
            const results = document.getElementById('results');
            results.innerHTML += `
                <h4>Merge Test Results</h4>
                <p>Can merge: ${result.canMerge}</p>
                <p>Original draw calls: ${result.analysis.originalDrawCalls}</p>
                <p>Check console for detailed transform analysis</p>
            `;
        };

        // Initialize when page loads
        init();
    </script>
</body>
</html>
